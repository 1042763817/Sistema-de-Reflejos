from machine import Pin
import time, random
import micropython

# CONFIGURACIÓN DE PINES

LED_PINS = (2, 4, 5)            # pines para los Leds
BUZZER_PIN = 18                 # Pin buzzer

# Botones jugador 1 (uno por cada salida: LED1, LED2, LED3, Buzzer)
J1_BTN_PINS = (12, 13, 14, 27)

# Botones jugador 2 (uno por cada salida: LED1, LED2, LED3, Buzzer)
J2_BTN_PINS = (32, 33, 25, 26)

BTN_INICIO_PIN = 19             # botón de inicio
BTN_FIN_PIN = 21                # botón para finalizar partida
IRQ_MODO3_PIN = 34              # boton de interrupcion , necesecita resistencia pull up fisica

# REGISTROS GPIO (ESP32)

GPIO_OUT_REG     = 0x3FF44004  # Registro de salida actual
GPIO_OUT_W1TS_REG = 0x3FF44008 # Write-1-To-Set esto es para poner un high
GPIO_OUT_W1TC_REG = 0x3FF4400C # Write-1-To-Clear esto es para poner un low


LED_MASK = 0
for p in LED_PINS:
    LED_MASK |= (1 << p)


# aqui se configuran los leds como salidas
leds = [Pin(p, Pin.OUT) for p in LED_PINS]

# Buzzer como salida 
buzzer = Pin(BUZZER_PIN, Pin.OUT)

# Botones de jugadores son entradas con pull down
botones_j1 = [Pin(p, Pin.IN, Pin.PULL_DOWN) for p in J1_BTN_PINS]
botones_j2 = [Pin(p, Pin.IN, Pin.PULL_DOWN) for p in J2_BTN_PINS]

# Botones de control tambien son entradas
btn_inicio = Pin(BTN_INICIO_PIN, Pin.IN, Pin.PULL_DOWN)
btn_fin = Pin(BTN_FIN_PIN, Pin.IN, Pin.PULL_DOWN)

# Interrupción modo 3
irq_pin = Pin(IRQ_MODO3_PIN, Pin.IN,Pin.PULL_DOWN)


# VARIABLES para los estados

puntaje_j1 = 0
puntaje_j2 = 0
modo3_disparado = False    # flag global que enciende el modo 3 por IRQ


# UTILIDADES DE LED POR REGISTROS

def leds_off_mask(mask=LED_MASK):
    import machine
    machine.mem32[GPIO_OUT_W1TC_REG] = mask

def leds_on_mask(mask):
    import machine
    machine.mem32[GPIO_OUT_W1TS_REG] = mask

def led_index_mask(i):
    pin = LED_PINS[i]
    return (1 << pin)

def leds_all_off():
    leds_off_mask(LED_MASK)

def leds_show_index(i):
    """Enciende solo el LED i en una sola escritura de registro"""
    import machine
    mask = led_index_mask(i)
    val = machine.mem32[GPIO_OUT_REG]
    machine.mem32[GPIO_OUT_REG] = (val & ~LED_MASK) | mask

def apagar_salidas():
    leds_all_off()
    buzzer.off()


# Antirebote para los pulsadores , software

def antirrebote(btn, hold_ms=20):
    if btn.value() == 1:
        time.sleep_ms(hold_ms)
        return btn.value() == 1
    return False

def sleep_con_interrupcion(segundos):
    global modo3_disparado
    fin_ms = time.ticks_add(time.ticks_ms(), int(segundos * 1000))
    while time.ticks_diff(fin_ms, time.ticks_ms()) > 0:
        if modo3_disparado:
            return 'irq'
        if antirrebote(btn_fin):
            return 'fin'
        time.sleep_ms(10)
    return 'ok'


# ENTRADAS DE JUEGO

def esperar_respuesta_1jugador(correcto):
    inicio = time.ticks_ms()
    while True:
        if antirrebote(btn_fin):
            return None, None
        if modo3_disparado:
            return 'irq', None

        for i, btn in enumerate(botones_j1):
            if antirrebote(btn):
                fin = time.ticks_ms()
                tiempo = time.ticks_diff(fin, inicio)
                return (tiempo, 0) if i == correcto else (tiempo, -1)

def esperar_respuesta_2jugadores(correcto):
    inicio = time.ticks_ms()
    while True:
        if antirrebote(btn_fin):
            return None, None, None
        if modo3_disparado:
            return 'irq', None, None

        for i, btn in enumerate(botones_j1):
            if antirrebote(btn):
                fin = time.ticks_ms()
                tiempo = time.ticks_diff(fin, inicio)
                return (1, tiempo, 0) if i == correcto else (1, tiempo, -1)

        for i, btn in enumerate(botones_j2):
            if antirrebote(btn):
                fin = time.ticks_ms()
                tiempo = time.ticks_diff(fin, inicio)
                return (2, tiempo, 0) if i == correcto else (2, tiempo, -1)


# JUEGOS

def ronda_generar_estimulo():
    estimulo = random.randint(0, 3)
    if estimulo == 3:
        buzzer.on()
    else:
        leds_show_index(estimulo)
    return estimulo

def juego_1jugador():
    global puntaje_j1, modo3_disparado
    puntaje_j1 = 0
    ronda = 0
    print("Modo: 1 Jugador")
    print("Presiona INICIO para comenzar...")
    while not antirrebote(btn_inicio):
        if modo3_disparado:
            juego_modo3()
            return
        time.sleep_ms(10)
    print("Juego iniciado!")

    while True:
        ronda += 1
        apagar_salidas()
        espera = random.randint(1, 10)
        s = sleep_con_interrupcion(espera)
        if s == 'fin':
            print("Juego finalizado")
            break
        if s == 'irq':
            juego_modo3()
            continue

        estimulo = ronda_generar_estimulo()
        print(f"\n--- Ronda {ronda} ---")
        print(f"Reacciona al estímulo {estimulo+1}")

        tiempo, penalizacion = esperar_respuesta_1jugador(estimulo)
        apagar_salidas()

        if tiempo is None and penalizacion is None:
            print("Juego finalizado")
            break
        if tiempo == 'irq':
            juego_modo3()
            continue

        if penalizacion == 0:
            puntaje_j1 += 1
            print(f"Correcto! Tiempo: {tiempo} ms | Puntaje J1: {puntaje_j1}")
        else:
            puntaje_j1 -= 1
            print(f"Incorrecto! Tiempo: {tiempo} ms | Puntaje J1: {puntaje_j1}")

        time.sleep(1)

    print(f"Puntaje final J1: {puntaje_j1}")

def juego_2jugadores():
    global puntaje_j1, puntaje_j2
    puntaje_j1 = 0
    puntaje_j2 = 0
    ronda = 0
    print("Modo: 2 Jugadores")
    print("Presiona INICIO para comenzar...")
    while not antirrebote(btn_inicio):
        if modo3_disparado:
            juego_modo3()
            return
        time.sleep_ms(10)
    print("Juego iniciado!")

    while True:
        ronda += 1
        apagar_salidas()
        espera = random.randint(1, 10)
        s = sleep_con_interrupcion(espera)
        if s == 'fin':
            print("Juego finalizado")
            break
        if s == 'irq':
            juego_modo3()
            continue

        estimulo = ronda_generar_estimulo()
        print(f"\n--- Ronda {ronda} ---")
        print(f"Reacciona al estímulo {estimulo+1}")

        jugador, tiempo, penal = esperar_respuesta_2jugadores(estimulo)
        apagar_salidas()

        if jugador is None and tiempo is None and penal is None:
            print("Juego finalizado")
            break
        if jugador == 'irq':
            juego_modo3()
            continue

        if penal == 0:
            if jugador == 1:
                puntaje_j1 += 1
                print(f"Jugador1 correcto! Tiempo: {tiempo} ms | J1: {puntaje_j1} | J2: {puntaje_j2}")
            else:
                puntaje_j2 += 1
                print(f"Jugador2 correcto! Tiempo: {tiempo} ms | J1: {puntaje_j1} | J2: {puntaje_j2}")
        else:
            if jugador == 1:
                puntaje_j1 -= 1
                print(f"Jugador1 incorrecto! Tiempo: {tiempo} ms | J1: {puntaje_j1} | J2: {puntaje_j2}")
            else:
                puntaje_j2 -= 1
                print(f"Jugador2 incorrecto! Tiempo: {tiempo} ms | J1: {puntaje_j1} | J2: {puntaje_j2}")

        time.sleep(1)

    print(f"Puntaje final — Jugador 1: {puntaje_j1} | Jugador2: {puntaje_j2}")
    if puntaje_j1 > puntaje_j2:
        print("Ganador: Jugador 1")
    elif puntaje_j2 > puntaje_j1:
        print("Ganador: Jugador 2")
    else:
        print("Empate!")


# MODO 3 — INTERRUPCIÓN

def _irq_handler(pin):
    global modo3_disparado
    modo3_disparado = True

irq_pin.irq(trigger=Pin.IRQ_RISING, handler=_irq_handler)

def juego_modo3():
    global modo3_disparado
    print("MODO 3 (Muerte Súbita) ACTIVADO POR INTERRUPCIÓN")
    modo3_disparado = False

    apagar_salidas()
    espera = random.randint(1, 10)
    s = sleep_con_interrupcion(espera)
    if s == 'fin':
        print("Cancelado por usuario.")
        return

    estimulo = ronda_generar_estimulo()
    print("¡Reacciona! (Muerte Súbita)")

    inicio = time.ticks_ms()
    ganador = None
    tiempo = None

    while True:
        if antirrebote(btn_fin):
            print("Cancelado por usuario.")
            apagar_salidas()
            return

        for i, btn in enumerate(botones_j1):
            if antirrebote(btn):
                fin = time.ticks_ms()
                tiempo = time.ticks_diff(fin, inicio)
                ganador = 'J1' if i == estimulo else 'Nadie (J1 erró)'
                apagar_salidas()
                break
        if ganador is not None:
            break

        for i, btn in enumerate(botones_j2):
            if antirrebote(btn):
                fin = time.ticks_ms()
                tiempo = time.ticks_diff(fin, inicio)
                ganador = 'J2' if i == estimulo else 'Nadie (J2 erró)'
                apagar_salidas()
                break
        if ganador is not None:
            break

    if ganador.startswith('J'):
        print(f"{ganador} gana la Muerte Súbita en {tiempo} ms")
    else:
        print(f" {ganador}. No hubo ganador válido.")


# MENÚ PRINCIPAL

def main():
    print("=== Juego de Reflejos (ESP32) ===")
    print("• LEDs por REGISTROS (GPIO W1TS/W1TC)")
    print("• Modo 3 por interrupción en GPIO", IRQ_MODO3_PIN)
    while True:
        print("\n===== MENÚ PRINCIPAL =====")
        print("1. Juego de 1 jugador")
        print("2. Juego de 2 jugadores")
        print("3. (El juego especial se activa con el botón de interrupción en cualquier momento si quiere)")
        opcion = input("Selecciona una opción: ")

        if opcion == "1":
            juego_1jugador()
        elif opcion == "2":
            juego_2jugadores()
        elif opcion == "3":
            print("El modo 3 se activa PRESIONANDO el botón en GPIO", IRQ_MODO3_PIN)
        else:
           
# Estado inicial seguro para que todo este apagado al inicio
apagar_salidas()
leds_all_off()


main()